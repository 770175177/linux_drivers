1,139c1,141
< #include <linux/init.h>
< #include <linux/module.h>
< /*define module_param module_param_array*/
< #include <linux/moduleparam.h>
< /*define parameter of module_param and module_param_array*/
< #include <linux/stat.h>
< /*char device functions*/
< #include <linux/fs.h>
< /*MKDEV transfer device number*/
< #include <linux/kdev_t.h>
< /*define char device structure*/
< #include <linux/cdev.h>
< /*allocate memery*/
< #include <linux/slab.h>
< 
< #define DEVICE_NAME  "dcdev"
< #define DEVICE_MINOR_NUM 2
< #define DEVICE_MAJOR     0
< #define DEVICE_MINOR     0
< #define REGDEV_SIZE      3000
< 
< MODULE_LICENSE("GPL");
< MODULE_AUTHOR("HengLiang");
< 
< int number_major = DEVICE_MAJOR;
< int number_minor = DEVICE_MINOR;
< 
< /*input major device number*/
< module_param(number_major, int, S_IRUSR);
< /*input minor device number*/
< module_param(number_minor, int, S_IRUSR);
< 
< struct reg_deg {
< 	char *data;
< 	unsigned long size;
< 
< 	struct cdev cdev;
< };
< 
< struct reg_deg *my_devices;
< 
< struct file_operations my_fops = {
< 	.owner  = THIS_MODULE,
< };
< 
< static void reg_init_cdev(struct reg_deg *dev, int index)
< {
< 	int err;
< 	int devno = MKDEV(number_major, number_minor + index);
< 
< 	cdev_init(&(dev->cdev), &my_fops);
< 	dev->cdev.owner = THIS_MODULE;
< 	dev->cdev.ops = &my_fops;
< 
< 	err = cdev_add(&(dev->cdev), devno, 1);
< 	if (err)
< 	{
< 		printk(KERN_EMERG "cdev_add %d is failed! ret %d\n", index, err);
< 	}
< 	else
< 	{
< 		printk(KERN_EMERG "cdev_add %d is success!\n", index);
< 	}
< }
< 
< static int cDev_init(void)
< {
< 	int ret = 0, i;
< 	dev_t num_dev;
< 
< 	printk(KERN_EMERG "number_major is %d!\n", number_major);
< 	printk(KERN_EMERG "number_minor is %d!\n", number_minor);
< 
< 	if(number_major)
< 	{
< 		num_dev = MKDEV(number_major, number_minor);
< 		ret = register_chrdev_region(num_dev, DEVICE_MINOR_NUM, DEVICE_NAME);
< 	}
< 	else
< 	{
< 		/*register device number dynamicly*/
< 		ret = alloc_chrdev_region(&num_dev, number_minor, DEVICE_MINOR_NUM, DEVICE_NAME);
< 		/*get major device number*/
< 		number_major = MAJOR(num_dev);
< 		number_minor = MINOR(num_dev);
< 		printk(KERN_EMERG "alloc_chrdev_region major %d!\n", number_major);
< 	}
< 
< 	if(ret < 0)
< 	{
< 		printk(KERN_EMERG "register_chardev_region request %d is failed!\n", number_major);
< 	}
< 
< 	my_devices = kmalloc(DEVICE_MINOR_NUM * sizeof(struct reg_deg), GFP_KERNEL);
< 	if (NULL == my_devices)
< 	{
< 		ret = -ENOMEM;
< 		goto fail;
< 	}
< 	memset(my_devices, 0, sizeof(DEVICE_MINOR_NUM * sizeof(struct reg_deg)));
< 	/*device initialize*/
< 	for (i = 0; i < DEVICE_MINOR_NUM; i++)
< 	{
< 		my_devices[i].data = kmalloc(REGDEV_SIZE, GFP_KERNEL);
< 		memset(&(my_devices[i].data), 0, REGDEV_SIZE);
< 		/*device register to system*/
< 		reg_init_cdev(&my_devices[i], i);
< 	}
< 
< 	printk(KERN_EMERG "Cdev Enter!\n");
< 	
< 	return 0;
< 
< fail:
< 	/*unregister device number*/
< 	unregister_chrdev_region(MKDEV(number_major, number_minor), DEVICE_MINOR_NUM);
< 	printk(KERN_EMERG "kmalloc is failed!\n");
< 	return ret;
< }
< 
< static void cDev_exit(void)
< {
< 	int i;
< 
< 	printk(KERN_EMERG "Cdev exit!\n");
< 
< 	/*unregister char device*/
< 	for (i = 0; i < DEVICE_MINOR_NUM; i++)
< 	{
< 		cdev_del(&(my_devices[i].cdev));
< 	}
< 
< 	unregister_chrdev_region(MKDEV(number_major, number_minor), DEVICE_MINOR_NUM);
< 
< 	return ;
< }
< 
< module_init(cDev_init);
< module_exit(cDev_exit);
---
> /*包含初始化宏定义的头文件,代码中的module_init和module_exit在此文件中*/
> #include <linux/init.h>
> /*包含初始化加载模块的头文件,代码中的MODULE_LICENSE在此头文件中*/
> #include <linux/module.h>
> /*定义module_param module_param_array的头文件*/
> #include <linux/moduleparam.h>
> /*定义module_param module_param_array中perm的头文件*/
> #include <linux/stat.h>
> /*三个字符设备函数*/
> #include <linux/fs.h>
> /*MKDEV转换设备号数据类型的宏定义*/
> #include <linux/kdev_t.h>
> /*定义字符设备的结构体*/
> #include <linux/cdev.h>
> 
> /*分配内存空间函数头文件*/
> #include <linux/slab.h>
> 
> #define DEVICE_NAME "ascdev"
> #define DEVICE_MINOR_NUM 2
> #define DEV_MAJOR 0
> #define DEV_MINOR 0
> #define REGDEV_SIZE 3000
> 
> MODULE_LICENSE("Dual BSD/GPL");
> /*声明是开源的，没有内核版本限制*/
> MODULE_AUTHOR("iTOPEET_dz");
> /*声明作者*/
> 
> int numdev_major = DEV_MAJOR;
> int numdev_minor = DEV_MINOR;
> 
> /*输入主设备号*/
> module_param(numdev_major,int,S_IRUSR);
> /*输入次设备号*/
> module_param(numdev_minor,int,S_IRUSR);
> 
> struct reg_dev
> {
> 	char *data;
> 	unsigned long size;
> 	
> 	struct cdev cdev;
> };
> struct reg_dev *my_devices;
> 
> struct file_operations my_fops = {
> 	.owner = THIS_MODULE,
> };
> 
> 
> /*设备注册到系统*/
> static void reg_init_cdev(struct reg_dev *dev,int index){
> 	int err;
> 	int devno = MKDEV(numdev_major,numdev_minor+index);
> 	
> 	/*数据初始化*/
> 	cdev_init(&dev->cdev,&my_fops);
> 	dev->cdev.owner = THIS_MODULE;
> 	dev->cdev.ops = &my_fops;
> 	
> 	/*注册到系统*/
> 	err = cdev_add(&dev->cdev,devno,1);
> 	if(err){
> 		printk(KERN_EMERG "cdev_add %d is fail! %d\n",index,err);
> 	}
> 	else{
> 		printk(KERN_EMERG "cdev_add %d is success!\n",index);
> 	}
> }
> 
> static int scdev_init(void)
> {
> 	int ret = 0,i;
> 	dev_t num_dev;
> 	
> 	
> 	printk(KERN_EMERG "numdev_major is %d!\n",numdev_major);
> 	printk(KERN_EMERG "numdev_minor is %d!\n",numdev_minor);
> 	
> 	if(numdev_major){
> 		num_dev = MKDEV(numdev_major,numdev_minor);
> 		ret = register_chrdev_region(num_dev,DEVICE_MINOR_NUM,DEVICE_NAME);
> 	}
> 	else{
> 		/*动态注册设备号*/
> 		ret = alloc_chrdev_region(&num_dev,numdev_minor,DEVICE_MINOR_NUM,DEVICE_NAME);
> 		/*获得主设备号*/
> 		numdev_major = MAJOR(num_dev);
> 		printk(KERN_EMERG "adev_region req %d !\n",numdev_major);
> 	}
> 	if(ret<0){
> 		printk(KERN_EMERG "register_chrdev_region req %d is failed!\n",numdev_major);		
> 	}
> 	
> 	my_devices = kmalloc(DEVICE_MINOR_NUM * sizeof(struct reg_dev),GFP_KERNEL);
> 	if(!my_devices){
> 		ret = -ENOMEM;
> 		goto fail;
> 	}
> 	memset(my_devices,0,DEVICE_MINOR_NUM * sizeof(struct reg_dev));
> 	
> 	/*设备初始化*/
> 	for(i=0;i<DEVICE_MINOR_NUM;i++){
> 		my_devices[i].data = kmalloc(REGDEV_SIZE,GFP_KERNEL);
> 		memset(my_devices[i].data,0,REGDEV_SIZE);
> 		/*设备注册到系统*/
> 		reg_init_cdev(&my_devices[i],i);
> 	}
> 	
> 		
> 	printk(KERN_EMERG "scdev_init!\n");
> 	/*打印信息，KERN_EMERG表示紧急信息*/
> 	return 0;
> 
> fail:
> 	/*注销设备号*/
> 	unregister_chrdev_region(MKDEV(numdev_major,numdev_minor),DEVICE_MINOR_NUM);
> 	printk(KERN_EMERG "kmalloc is fail!\n");
> 	
> 	return ret;
> }
> 
> static void scdev_exit(void)
> {
> 	int i;
> 	printk(KERN_EMERG "scdev_exit!\n");
> 	
> 	/*除去字符设备*/
> 	for(i=0;i<DEVICE_MINOR_NUM;i++){
> 		cdev_del(&(my_devices[i].cdev));
> 	}
> 		
> 	unregister_chrdev_region(MKDEV(numdev_major,numdev_minor),DEVICE_MINOR_NUM);
> }
> 
> 
> module_init(scdev_init);
> /*初始化函数*/
> module_exit(scdev_exit);
> /*卸载函数*/
\ No newline at end of file
